
# Разработка: Узники системы

Привет! Я Ваня. За последние 10 лет меня покидало по разным специализациям. Я занимался и фул стек веб-разработкой,
и мобильными приложениями, а последние лет 5 &mdash; играми. Теперь вот в Microsoft занесло.

Когда я был еще личинкой разработчика, я любил программирование больше всего на свете. Возможность
писать код (Да еще и получать за это деньги!) туманила разум. Получив свою первую профессиональную работу
веб-разработчиком, я был на седьмом небе от счастья и не мог поверить, что так бывает.
Но и в этой бочке нашлась ложка дегтя &mdash; менеджеры.

Выкидыши системы. Они не понимали и не хотели понимать почему фичу, которую они просят, нельзя сделать быстро.
А я не хотел объяснять. Я хотел писать код. Хотел чтобы мне не мешали. Они заставляли меня создавать
задачи в трекере и логгировать время. Они заставляли меня ходить на митинги
полные пустых разговоров. Зачем все это? Я просто хочу писать код. Почему я должен общаться с
этими людьми? Они не понимают и десятой части того, о чем я говорю. Как было бы хорошо избавиться
от всей этой бюрократической чуши! Игры! В разработке игр наверняка нет всей этой ереси!

[more]

## Глоток свободы

**И вот, спустя несколько лет я попал в мир грез.** Разработка игр. Я устроился в новообразовавшуюся студию.
Кроме меня и моей начальницы больше никого не было. Она мне дала общее описание проекта. Никаких деталей.
И сказала, мол, начни делать что-нибудь. Неделю я просто писал код, работая над прототипом.
Никаких митингов, никаких таск-трекеров, никаких отчетов.
С меня ничего не спрашивали. Я подумал: "Боже, я что в рай что ли попал?".

**Мы реализовывали все клевые идеи, которые только появлились в нашей голове**. Было весело.
Но однажды на нас сверху спустили требования и сроки. Все изменилось. Объем работы вырос.
Я один не справлялся. Мы наняли несколько разработчиков.

**Мы делили работу между собой, но работали очень неформально**. Сроки, конечно, были, но никто
не дышал в затылок. В какой-то момент я заметил, что мы часто обсуждаем важные детали устно.
Это приводило к тому, что мы забывали что-то доделать, или забывали о некоторых задачах и багах совсем.
Они просто терялись.

**Мы хаотично переключались от багов к задачам и наоборот.**

Это подтолкнуло нас к первому шагу в сторону порядка &mdash; таск трекер. А ведь я так это не любил. Мне всегда
это казалось чисто формальным и совсем не нужным.

**Мы стали все фиксировать в трекере**. Со временем. Стали меньше забывать о чем-то.
**Мы не теряли баги**. В хаосе появился кусочек порядка. **Мы начали
фокусироваться только на самых важных задачах**. Мы стали понимать сколько успеем за неделю.

В этот момент я осознал, что все эти процессы, которые мне казались бюрократией,
были придуманы людьми не просто так.

## Погружение

Не знаю, то ли это я стал опытнее, то ли это бремя ответственности за проект, свалившееся
на меня как на лида. Но я начал понимать, что мы тратим кучу времени на какие-то левые вещи.

Пока мы разрабатывали игрушку, очень важно было постоянно получать фидбек, чтобы двигаться в правильном
направлении. Мы постоянно собирали билды и выкладывали их на портал, чтобы люди могли поиграть.
**Фактически, мы работали по Agile схеме**. Но у нас не было стендапов. Спринта официально тоже не было,
но мы работали итерациями длиной в неделю. Спринт планнинг был условным, а ревью и ретроспективы не было
совсем. Иначе говоря, у нас **не было митингов с кучей пустой болтовни**, и я не заметил какого-либо
ущерба от этого.

Разработка прототипа предполагает, что все делается очень быстро. А это означает и частую сборку билдов
для демонстрации проделанной работы. В то время мы писали на C++, и время сборки билда нас удручало.
В конце концов у нас бомбануло от того что билд нужно собирать несколько раз в день. **Мы поставили
билд сервер** и настроили:

- сборку билда по коммиту
- деплой билда в демо-портал
- уведомление о том, что билд не собрался и список предполагаемых виновников

**Сколько времени освободилось!** Больше не надо было прерываться посреди задачи, чтобы собрать билд
для "шишек", которые хотят его посмотреть прямо сейчас.

**С появлением билд сервера пришла новая проблема**. Билд стал часто ломаться. Хотя мы и могли сказать
"Берите предыдущий билд, последний пока не работает" &mdash; это был не самый удобный вариант.

Проблема заключалась в том, что все коммитили в master. Многие коммитили не убедившись, что их
коммит не поломал билд. Или не привнес регрессионный баг. Чтобы побороть эту проблему, пришлось
внедрить еще одно правило. **Мы стали работать по git flow.**

Мы стали строго следовать ему и прониклись его идеологией. Работа стала легче.
Легче стало сливать изменения в один бранч. Мы разделили билды
на release, dev-stable, nightly. Все стали ответственнее относиться к тому, что они делают.
Позже мы стали уделять внимание и коммит-месседжам. Привязывать их к тикетам в таск-трекере.

После первого релиза приложения, как это бывает, от юзеров стало поступать много жалоб. Приложение падает,
это не работает, то, сё. Проблема была в том, что мы никак не могли получить подробной информации
из жалобы. Нам нужно было либо воспроизвести баг силами QA, либо найти способ получить диагностическую
информацию. QA может отловить только маленькую часть ошибок. На самые лютые баги всегда натыкаются
ваши лояльные пользователи.

Все это потребовало внедрения системы аналитики и мониторинга, которые помогли нам диагностировать
кучу проблем, о которых мы даже не подозревали. **О многих ошибках юзеры даже не сообщали.**
В моем воображении они просто орали матом, а потом удаляли игру к чертям.

Мы не хотели сильно портить свою карму, поэтому стали проверять все ошибки, которые сыпятся с
продакшен билдов. Никто не хочет стать сейлзом в следующей жизни,
поэтому такие баги фиксились довольно быстро.

## На границе

Вот так, я начал практиковать те вещи, которые раньше ненавидел. **Презрение сменилось пониманием**.
Пришло и осознание, что проблема не в процессах, а в том как их трактуют.
Проблема, как оказалось, глобальна. Люди, придумавшие Scrum, хотели сделать жизнь разработчиков лучше.
Но за годы оно превратилось в то, что авторы назвали [Dark Scrum](http://ronjeffries.com/articles/016-09ff/defense/).

Взяв простые и понятные правила, люди смогли извратить их до неузнаваемости. А потом стали жаловаться,
что Scrum не работает.

**В последнее время все говорят о DevOps.** У термина куча определений. Но я знаю одно &mdash;
DevOps должны делать жизнь людей проще. Нужно быть на границе между
хаосом и порядком. Крайностей быть не должно. Плохо сваливаться в анархию и тонуть в сумбурности
процессов. Ровно как и стремиться к тотальному контролю. Заставлять людей следовать процессам,
которые только мешают.

Найти баланс сложно. Но чтобы его найти, нужно хотеть этого. У вас три пути:

- тихонько ныть, что все плохо, но молчать, надеясь что почему-то станет лучше
- взять все в свои руки и бороться за то, чтобы процессы помогали вам, а не мешали
- искать нового работодателя, надеясь что там все будет лучше

В любом случае, решать только вам.

В [следующей статье]() я расскажу о шагах к порядку. Многим они известны. Но я расскажу о нюансах,
которые я понял за последние годы.


# Разработка: От хаоса к порядку

В [предыдущей статьей]() я рассказал о том, как жизнь заставила меня осознать необходимость порядка.
Как я стал любить то, что раньше ненавидел.

В этой статье я расскажу о конкретных шагах к порядку в процессах разработки ПО.
Этот порядок я понимаю как DevOps. О DevOps говорят все чаще. Это не просто хайп. Это необходимость.
Это прописные истины. Вы можете найти их во многих книгах.
Но люди отказываются их понимать. Отторгают их.

DevOps цикл уникален для каждой компании. Может даже для проекта. Но давайте разберемся не
"как", а "зачем".

[more]

Актуальность и польза от выстраивания процесса разработки зависит от кучи факторов:

- тип проекта
- размер команды
- поставленные сроки
- сложность проекта
- опытность разработчиков
- фаза проекта

Никто кроме вас не сможет понять когда и как лучше всего начать упорядочивать работу.

## Планирование

Даже примитивные проекты не так просты, какими кажутся на первый взгляд.
Планирование &mdash; основополагающий этап цикла разработки ПО. Раньше я не уделял планированию
много внимания. Я считал что я и так могу оценить задачу, в голове. Я знаю что и как мне нужно делать.

Свое мнение я начал менять, когда часто стал ошибаться в оценке. Задачи были сложнее, чем казались
сначала. Я вспомнил стандартные решения данной проблемы. Идея проста:
- Создать топ-левел задачу в таск-трекере. Про нее уже будет сложно забыть или упустить из виду.
- Максимально подробно разбить ее на подзадачи. Чем подробнее она разбита, тем меньше вероятность
что-то упустить из виду
- Оценить каждую из подзадач отдельно. Мелкие задачи проще оценивать

> Если вы видите, что задачу все равно сложно детально оценить и нужно исследовать, добавьте задачу
на оценку. Проставьте время на исследование. В итоге это все равно выйдет дешевле, чем изначально
неправильная оценка.

В итоге у топ-левел задачи формируется примерная оценка, на основе подзадач. Дальше я брал и увеличивал
каждую из оценок подзадач на **коэффициент R **(Risk). Коэффициент выясняется опытным путем. Его нужно
корректировать, когда вы сильно ошибаетесь в оценке. Таким образом я закладываю в оценку буфер,
который можно потом использовать на непредвиденные обстоятельства (жесткие баги). Либо распределить
на другие задачи.

> Оценка &mdash; самая сложная задача. Программисты очень плохи в оценке. Все зависит и от
задачи. Как, блин, оценить сколько времени фиксить баг, если ты даже не можешь его воспроизвести?

Есть те, кто думает, что для маленьких команд планирование &mdash; лишняя трата времени. Я считаю,
что планирование **положительно сказывается на разработке**. Не зависимо от размера команды.
У вас будут сроки, и в эти сроки вам необходимо уложиться.

Даже когда я работаю один, я уделяю значительную часть времени планированию задач. Особенно это важно
при работе над проектами в свободное время. Его всегда мало.

> Лайф-хак: При планировании спринта учитывайте, что всегда будут баги. Нужно резервировать время под них.
Это можно сделать либо введя другой коэффициент, либо не забивая спринт под завязку.

Чем мне помогает планирование:

- **Я знаю сколько нужно времени**.
- **Я знаю что мне делать**. В любой момент времени. Когда у тебя появляется часик-другой
поработать над проектом, много времени может уйти на то чтобы настроиться. Нужно вспомнить
где ты остановился в прошлый раз, что нужно делать дальше, что ты можешь успеть за то время,
что у тебя есть. Если у тебя есть план и оценка задач, ты можешь сразу браться за работу.
- **Я вижу прогресс**. Закрывая задачи я вижу сколько еще осталось. Гораздо легче оценивать
свой прогресс и темп.
- **Я могу делегировать задачи**. В случае если ко мне кто-то присоединится чтобы помочь, я всегда могу
 просто перекинуть задачу, а не объяснять что и как (при условии что задача подробно описана).
- **Я знаю когда нужно остановиться**. Задачи служат своего рода контрольными точками. После выполнения
задачи можно со спокойной совестью остановиться. Для меня проблема взять и остановиться на какой-то
точке. Когда я делал только топ-левел задачи, я не мог успокоиться пока их не закрою. Сейчас я могу
остановиться после выполнения любой из подзадач.
- **Я имею понимание о количестве багов**. Баги -- это часть планирования, поэтому я всегда понимаю
сколько времени нужно потратить на приведение проекта в порядок. Я не забуду починить что-то, ведь
на это есть задача.

В больших командах важность планирования имеет еще большую ценность.
Представьте, если планирование так важно для самоорганизации разработчиков, насколько оно может быть
важно для лидов, менеджеров и т.п. Вы работаете в команде, и успех командной работы зависит от
понимая прогресса каждого участника.

## Разработка

Если работа на этапе планирования была проведена должным образом, то разработка становится проще.
На этом этапе у вас уже должны быть подробные задачи для работы, но нет деталей реализации.

### Архитектура

Раньше я очень редко занимался архитектурным проектированием как выделенной задачей. Я брал требования
и начинал писать код. Далее я правил архитектуру итерациями, с каждым разом улучшая ее. Этот подход
работает. Но у него есть недостатки.

На разработку архитектуры необходимо приглашать коллег, ведь это как парное программирование,
другие люди могут видеть те недостатки, которые не видите вы. В дискуссиях рождаются интересные
решения.

В случае если у вас клиент-серверное приложение, то стоит проводить сессии, в которых участвуют
и клиентские, и серверные разработчики. Это убережет вас от необходимости переделывать ваше решение,
когда оно дойдет до коллег, и они поймут, что это не удобно. Опять же, вы &mdash; команда.

К тому же, все будут в курсе в каком направлении будет осуществляться работа.
По аналогии с планированием, архитектурные сессии упрощают этап реализации.

### Написание кода

Конечно дискуссии про "чистый код" и тому подобное &mdash; вне рамок этой статьи.
Я хочу затронуть общие аспекты.

Разработчики должны фокусироваться на разработке, а не на рутинных операциях. Все рутинные операции
должны быть автоматизированы.

#### Система контроля версий

Распространенные проблемы при работе с системой контроля версий:
	- **Часто ломается билд**. Один из бранчей всегда должен быть релизным. Выкачал, запустил и сразу в бой.
	- **Трудный мердж**. Git позволяет довольно просто мержить бранчи. Можно пользовать git flow или что-то похожее.
	- **Не понятно что вошло в релиз**. Пишите нормальные коммит-месседжи. При интеграции с билд системами они помогут сформировать
	нормальный чендж лог.
	- **Трудно найти в чем заключался баг**. Баги бывает переоткрывают. В таком случае удобно понимать
	какую работу проделал последний автор. Если добавить номер тикета, то искать по коммитам будет просто!
	- **Не понятно с какой ревизии собран билд**. Используйте отдельные бранчи для релизов или теги.

> Вообще, я был в шоке, узнав, что все еще есть люди, хранящие свой код в Dropbox!

#### Билд система

Билд система позволяет автоматизировать сразу пачку рутинных операций:

- сборка билда - делается в одну кнопку. Может сделать даже менеджер. Невозможно что-то забыть. Все
автоматически.
- прогон тестов - забыл пронать тесты? билд сервер не забудет
- уведомление о поломке - что-то поломал? бегом чинить!
- управление артефактами - собрал билд? ну не кидать же его по скайпу!

#### Деплой система

С точки зрения разработчика автоматизация билдов и деплоев позволяет экономить время и избавиться
от рутинных операций.
С точки зрения бизнеса &mdash; снизить вероятность человеческой ошибки. Как легко забыть что-то
настроить.

Пофиксил баг, закоммитил, замержил в релизный бранч &mdash забыл. Само все задеплоится куда надо.
Работаешь с теми инструментами, которые тебе удобны. Можно не вылазить из IDE.


### Код ревью

Код ревью &mdash; очень полезный процесс. С одной стороны он позволяет выявить недостатки в вашем коде,
которые вы не сможете сами найти. С другой стороны он помогает прокачаться.

Например, Вася закончил работать над какой-то фичей. Вася приглашает коллег на код ревью. Коллеги
помогли обнаружить, что Вася продублировал часть функционала, который уже есть.
Так же в ходе ревью выяснилось,
что часть вещей не поддерживается серверной архитектурой, о чем Вася не знал,
так как работает только над клиентским кодом.

Разработчики могут прокачиваться как получая комментарии от коллег, так и читая чужой код.
Я часто видел как коллеги решают задачу не так как ее решил бы я, интереснее и лучше.
В таких случаях открываешь для себя много нового.

Код ревью является хорошим контролем качества. Если в команде есть джуниор, я бы не стал давать ему
коммитить в мастер без код-ревью :). Да и если код-ревью регулярны, коллеги обычно несколько раз
подумают, прежде чем полениться и закостылить.

## Тестирование

Тестирование &mdash; основной способ контроля качества продукта. К сожалению многие слишком полагаются
на ручное тестирование программ, которое может помочь отловить только маленькую толику проблем.

Помимо ручного тестирования существуют несколько других видов, которые могут быть гораздо эффективнее.

### Unit-тесты

Самый простой вид тестирования. Об их пользе
[много всякого написано](https://stackoverflow.com/questions/67299/is-unit-testing-worth-the-effort).
Тем не менее многие упорно их избегают. В моей практике даже точечное внедрение unit-тестов улучшает
ситуацию. Особенно хорошо влияет на общую архитектуру &mdash; известный эффект.

Люди впадают в крайности. На проекте либо нет тестов совсем, либо
TDD. Не многие готовы пойти на TDD. Попробуйте внедрять тесты постепенно. Начните писать тесты только
для новых фич. Возможно будут сложности с перестройкой архитектуры, чтобы она поддавалась тестированию.
Но это пойдет только на пользу.

TDD &mdash; довольно спорный подход, но я считаю, что гораздо быстрее
запилить по-быстрому unit test, конкретными тест кейсами, чем проверять код в райнтайме, каждый раз
доходя до нужного места, воссоздавая все необходимые условия.

В случае с тестом ты просто тыкаешь на кнопку "запустить тест". И все необходимые проверки выполняются
за секунду.

В случае, когда код меняется часто, количество итерации проверки значительно. При ручном тестировании
теряется очень много времени. Поэтому даже при ручном тестировании я рекомендую сделать "песочницу"
с минимальным количеством зависимостей, чтобы можно было приступить к тестированию сразу после загрузки
приложения.

> Я считаю что ко всему нужно подходить рационально и делать исключения из правил, если игра стоит свеч.
Например, если у вас горит дедлайн, и старый код не дает нормально написать TDD, то, мне кажется,
нормально начать с написания бизнес логики. Но в этом случае нужно **обязательно поставить таску на
покрытие нового функционала тестами**. Таким образом будет соблюден баланс, а исключение из правил
зафиксировано в трекере.

