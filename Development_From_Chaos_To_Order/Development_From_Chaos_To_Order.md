# Разработка: От хаоса к порядку

В [предыдущей статьей](../Development_Prisoners/Development_Prisoners.md) я рассказал о том, как жизнь заставила меня осознать необходимость порядка.
Как я стал любить то, что раньше ненавидел.

В этой статье я расскажу о конкретных шагах к порядку в процессах разработки ПО.
Этот порядок я понимаю как DevOps. О DevOps говорят все чаще. Это не просто хайп. Это необходимость.
Это прописные истины. Вы можете найти их во многих книгах.
Но люди отказываются их понимать. Отторгают их.

DevOps цикл уникален для каждой компании. Может даже для проекта. Но давайте разберемся не
"как", а "зачем".

[more]

Актуальность и польза от выстраивания процесса разработки зависит от кучи факторов:

- тип проекта
- размер команды
- поставленные сроки
- сложность проекта
- опытность разработчиков
- фаза проекта

Никто кроме вас не сможет понять когда и как лучше всего начать упорядочивать работу.

## Планирование

Даже примитивные проекты не так просты, какими кажутся на первый взгляд.
Планирование &mdash; основополагающий этап цикла разработки ПО. Раньше я не уделял планированию
много внимания. Я считал что я и так могу оценить задачу, в голове. Я знаю что и как мне нужно делать.

Свое мнение я начал менять, когда часто стал ошибаться в оценке. Задачи были сложнее, чем казались
сначала. Я вспомнил стандартные решения данной проблемы. Идея проста:
- Создать топ-левел задачу в таск-трекере. Про нее уже будет сложно забыть или упустить из виду.
- Максимально подробно разбить ее на подзадачи. Чем подробнее она разбита, тем меньше вероятность
что-то упустить из виду
- Оценить каждую из подзадач отдельно. Мелкие задачи проще оценивать

> Если вы видите, что задачу все равно сложно детально оценить и нужно исследовать, добавьте задачу
на оценку. Проставьте время на исследование. В итоге это все равно выйдет дешевле, чем изначально
неправильная оценка.

В итоге у топ-левел задачи формируется примерная оценка, на основе подзадач. Дальше я брал и увеличивал
каждую из оценок подзадач на **коэффициент R **(Risk). Коэффициент выясняется опытным путем. Его нужно
корректировать, когда вы сильно ошибаетесь в оценке. Таким образом я закладываю в оценку буфер,
который можно потом использовать на непредвиденные обстоятельства (жесткие баги). Либо распределить
на другие задачи.

> Оценка &mdash; самая сложная задача. Программисты очень плохи в оценке. Все зависит и от
задачи. Как, блин, оценить сколько времени фиксить баг, если ты даже не можешь его воспроизвести?

Есть те, кто думает, что для маленьких команд планирование &mdash; лишняя трата времени. Я считаю,
что планирование **положительно сказывается на разработке**. Не зависимо от размера команды.
У вас будут сроки, и в эти сроки вам необходимо уложиться.

Даже когда я работаю один, я уделяю значительную часть времени планированию задач. Особенно это важно
при работе над проектами в свободное время. Его всегда мало.

> Лайф-хак: При планировании спринта учитывайте, что всегда будут баги. Нужно резервировать время под них.
Это можно сделать либо введя другой коэффициент, либо не забивая спринт под завязку.

Чем мне помогает планирование:

- **Я знаю сколько нужно времени**.
- **Я знаю что мне делать**. В любой момент времени. Когда у тебя появляется часик-другой
поработать над проектом, много времени может уйти на то чтобы настроиться. Нужно вспомнить
где ты остановился в прошлый раз, что нужно делать дальше, что ты можешь успеть за то время,
что у тебя есть. Если у тебя есть план и оценка задач, ты можешь сразу браться за работу.
- **Я вижу прогресс**. Закрывая задачи я вижу сколько еще осталось. Гораздо легче оценивать
свой прогресс и темп.
- **Я могу делегировать задачи**. В случае если ко мне кто-то присоединится чтобы помочь, я всегда могу
 просто перекинуть задачу, а не объяснять что и как (при условии что задача подробно описана).
- **Я знаю когда нужно остановиться**. Задачи служат своего рода контрольными точками. После выполнения
задачи можно со спокойной совестью остановиться. Для меня проблема взять и остановиться на какой-то
точке. Когда я делал только топ-левел задачи, я не мог успокоиться пока их не закрою. Сейчас я могу
остановиться после выполнения любой из подзадач.
- **Я имею понимание о количестве багов**. Баги -- это часть планирования, поэтому я всегда понимаю
сколько времени нужно потратить на приведение проекта в порядок. Я не забуду починить что-то, ведь
на это есть задача.

В больших командах важность планирования имеет еще большую ценность.
Представьте, если планирование так важно для самоорганизации разработчиков, насколько оно может быть
важно для лидов, менеджеров и т.п. Вы работаете в команде, и успех командной работы зависит от
понимая прогресса каждого участника.

## Разработка

Если работа на этапе планирования была проведена должным образом, то разработка становится проще.
На этом этапе у вас уже должны быть подробные задачи для работы, но нет деталей реализации.

### Архитектура

Раньше я очень редко занимался архитектурным проектированием как выделенной задачей. Я брал требования
и начинал писать код. Далее я правил архитектуру итерациями, с каждым разом улучшая ее. Этот подход
работает. Но у него есть недостатки.

На разработку архитектуры необходимо приглашать коллег, ведь это как парное программирование,
другие люди могут видеть те недостатки, которые не видите вы. В дискуссиях рождаются интересные
решения.

В случае если у вас клиент-серверное приложение, то стоит проводить сессии, в которых участвуют
и клиентские, и серверные разработчики. Это убережет вас от необходимости переделывать ваше решение,
когда оно дойдет до коллег, и они поймут, что это не удобно. Опять же, вы &mdash; команда.

К тому же, все будут в курсе в каком направлении будет осуществляться работа.
По аналогии с планированием, архитектурные сессии упрощают этап реализации.

### Написание кода

Конечно дискуссии про "чистый код" и тому подобное &mdash; вне рамок этой статьи.
Я хочу затронуть общие аспекты.

Разработчики должны фокусироваться на разработке, а не на рутинных операциях. Все рутинные операции
должны быть автоматизированы.

#### Система контроля версий

Распространенные проблемы при работе с системой контроля версий:
	- **Часто ломается билд**. Один из бранчей всегда должен быть релизным. Выкачал, запустил и сразу в бой.
	- **Трудный мердж**. Git позволяет довольно просто мержить бранчи. Можно пользовать git flow или что-то похожее.
	- **Не понятно что вошло в релиз**. Пишите нормальные коммит-месседжи. При интеграции с билд системами они помогут сформировать
	нормальный чендж лог.
	- **Трудно найти в чем заключался баг**. Баги бывает переоткрывают. В таком случае удобно понимать
	какую работу проделал последний автор. Если добавить номер тикета, то искать по коммитам будет просто!
	- **Не понятно с какой ревизии собран билд**. Используйте отдельные бранчи для релизов или теги.

> Вообще, я был в шоке, узнав, что все еще есть люди, хранящие свой код в Dropbox!

#### Билд система

Билд система позволяет автоматизировать сразу пачку рутинных операций:

- сборка билда - делается в одну кнопку. Может сделать даже менеджер. Невозможно что-то забыть. Все
автоматически.
- прогон тестов - забыл пронать тесты? билд сервер не забудет
- уведомление о поломке - что-то поломал? бегом чинить!
- управление артефактами - собрал билд? ну не кидать же его по скайпу!

#### Деплой система

С точки зрения разработчика автоматизация билдов и деплоев позволяет экономить время и избавиться
от рутинных операций.
С точки зрения бизнеса &mdash; снизить вероятность человеческой ошибки. Как легко забыть что-то
настроить.

Пофиксил баг, закоммитил, замержил в релизный бранч &mdash забыл. Само все задеплоится куда надо.
Работаешь с теми инструментами, которые тебе удобны. Можно не вылазить из IDE.


### Код ревью

Код ревью &mdash; очень полезный процесс. С одной стороны он позволяет выявить недостатки в вашем коде,
которые вы не сможете сами найти. С другой стороны он помогает прокачаться.

Например, Вася закончил работать над какой-то фичей. Вася приглашает коллег на код ревью. Коллеги
помогли обнаружить, что Вася продублировал часть функционала, который уже есть.
Так же в ходе ревью выяснилось,
что часть вещей не поддерживается серверной архитектурой, о чем Вася не знал,
так как работает только над клиентским кодом.

Разработчики могут прокачиваться как получая комментарии от коллег, так и читая чужой код.
Я часто видел как коллеги решают задачу не так как ее решил бы я, интереснее и лучше.
В таких случаях открываешь для себя много нового.

Код ревью является хорошим контролем качества. Если в команде есть джуниор, я бы не стал давать ему
коммитить в мастер без код-ревью :). Да и если код-ревью регулярны, коллеги обычно несколько раз
подумают, прежде чем полениться и закостылить.

## Тестирование

Тестирование &mdash; основной способ контроля качества продукта. К сожалению многие слишком полагаются
на ручное тестирование программ, которое может помочь отловить только маленькую толику проблем.

Помимо ручного тестирования существуют несколько других видов, которые могут быть гораздо эффективнее.

### Unit-тесты

Самый простой вид тестирования. Об их пользе
[много всякого написано](https://stackoverflow.com/questions/67299/is-unit-testing-worth-the-effort).
Тем не менее многие упорно их избегают. В моей практике даже точечное внедрение unit-тестов улучшает
ситуацию. Особенно хорошо влияет на общую архитектуру &mdash; известный эффект.

Люди впадают в крайности. На проекте либо нет тестов совсем, либо
TDD. Не многие готовы пойти на TDD. Попробуйте внедрять тесты постепенно. Начните писать тесты только
для новых фич. Возможно будут сложности с перестройкой архитектуры, чтобы она поддавалась тестированию.
Но это пойдет только на пользу.

TDD &mdash; довольно спорный подход, но я считаю, что гораздо быстрее
запилить по-быстрому unit test, конкретными тест кейсами, чем проверять код в райнтайме, каждый раз
доходя до нужного места, воссоздавая все необходимые условия.

В случае с тестом ты просто тыкаешь на кнопку "запустить тест". И все необходимые проверки выполняются
за секунду.

В случае, когда код меняется часто, количество итерации проверки значительно. При ручном тестировании
теряется очень много времени. Поэтому даже при ручном тестировании я рекомендую сделать "песочницу"
с минимальным количеством зависимостей, чтобы можно было приступить к тестированию сразу после загрузки
приложения.

> Я считаю что ко всему нужно подходить рационально и делать исключения из правил, если игра стоит свеч.
Например, если у вас горит дедлайн, и старый код не дает нормально написать TDD, то, мне кажется,
нормально начать с написания бизнес логики. Но в этом случае нужно **обязательно поставить таску на
покрытие нового функционала тестами**. Таким образом будет соблюден баланс, а исключение из правил
зафиксировано в трекере.
